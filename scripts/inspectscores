#!/usr/bin/env python

import argparse
import sqlite3
import numpy as np
from datasets import Dataset
from pprint import pprint
from itertools import product
from tabulate import tabulate

from IPython.terminal.embed import InteractiveShellEmbed

def main(args):
    pth = args.path
    con = sqlite3.connect(pth)
    cur = con.cursor()
    tables = list(list(zip(*cur.execute(
        'select name from sqlite_master where type="table";'
    ).fetchall()))[0])
    try:
        views = list(list(zip(*cur.execute(
            'select name from sqlite_master where type="view";'
        ).fetchall()))[0])
    except:
        views = []

    columns = dict()
    for name in tables:
        tbl_info = cur.execute(f"PRAGMA table_info({name});").fetchall()
        _, cols, _, _, _, _ = zip(*tbl_info)
        columns[name] = list(cols)
    for name in views:
        view_info = cur.execute(f"PRAGMA table_info({name});").fetchall()
        _, cols, _, _, _, _ = zip(*view_info)
        columns[name] = list(cols)

    metrics, = zip(*cur.execute(
        'select * from metric_names'
    ).fetchall())
    joinstr = '\n'
    query = (
        f"""
        CREATE VIEW IF NOT EXISTS scores AS
        SELECT R.rowid as resp_id, R.model, R.temperature, P.template_name, P.problem_id, P.template_id, P.sys_id, F.problem, F.answer, P.prompt_text, R.response, {', '.join([f'{met}.score AS {met}' for met in metrics])}
        FROM responses R
        JOIN prompts P on R.prompt_id=P.rowid
        JOIN fitb_problems F on P.problem_id=F.rowid
        JOIN source_data C on F.ref_id=C.rowid
        {joinstr.join([f'JOIN {met} on {met}.resp_id=R.rowid' for met in metrics])}
        """
    )
    res = cur.execute(query)

    keys = [
        'resp_id', 'model', 'temperature', 'template_name', 'problem_id', 
        'template_id', 'sys_id', 'problem', 'answer', 'prompt_text', 
        'response', 
    ] + list(metrics)

    out_table = []

    # get some list values
    res = cur.execute('SELECT DISTINCT template_name from scores')
    template_names, = list(zip(*res.fetchall()))
    res = cur.execute('SELECT DISTINCT model from scores')
    model_names, = list(zip(*res.fetchall()))

    for tmplt, model_name in product(template_names, model_names):
        # get template ids
        res = cur.execute(f'SELECT DISTINCT template_id from scores S where S.template_name="{tmplt}"')
        tids, = list(zip(*res.fetchall()))

        # get sys_ids
        res = cur.execute(f'SELECT DISTINCT sys_id from scores S where S.template_name="{tmplt}"')
        sids, = list(zip(*res.fetchall()))

        # get temperatures
        res = cur.execute(f'SELECT DISTINCT temperature from scores S where S.template_name="{tmplt}"')
        temps, = list(zip(*res.fetchall()))

        for tid, sid, temp in product(tids, sids, temps):
            res = cur.execute(
                f"""
                SELECT {', '.join(keys)} FROM scores S
                WHERE S.template_name="{tmplt}" 
                    AND S.model="{model_name}"
                    AND S.sys_id={sid} 
                    AND S.template_id={tid} 
                    AND S.temperature={temp}
                """
            )
            data = dict(zip(keys, zip(*res.fetchall())))
            data_keys = list(data.keys())
            N = len(data[data_keys[0]])
            r1 = np.array(data['rouge1'])
            bs = np.array(data['bertscore_f1'])
            out_table.append({
                'model': model_name,
                'temperature': temp,
                'template': tmplt,
                'tid': tid,
                'sid': sid,
                'total': N,
                'avg rouge': np.mean(r1),
                'zeros rouge': np.sum(r1 == 0),
                'pct zeros rouge': np.mean(r1 == 0),
                'avg bertscore': np.mean(bs),
                'zeros bertscore': np.sum(bs == 0),
                'pct zeros bertscore': np.mean(bs == 0),
            })
    print(tabulate(out_table, headers='keys', tablefmt='github'))

    out_data = Dataset.from_list(out_table)
    out_vars = []
    for tmplt in template_names:
        res = cur.execute(f'SELECT DISTINCT template_id from scores S where S.template_name="{tmplt}"')
        tids, = list(zip(*res.fetchall()))
        res = cur.execute(f'SELECT DISTINCT sys_id from scores S where S.template_name="{tmplt}"')
        sids, = list(zip(*res.fetchall()))
        for tid in tids:
            fdata = out_data.filter(
                lambda x: x['template'] == tmplt and x['tid'] == tid
            )
            out_vars.append({
                'template': tmplt,
                'pool_by': f'tid={tid}',
                'avg rouge': np.mean(fdata['avg rouge']),
                'rouge var': np.var(fdata['avg rouge']),
                'N': len(fdata),
            })
        for sid in sids:
            fdata = out_data.filter(
                lambda x: x['template'] == tmplt and x['sid'] == sid
            )
            out_vars.append({
                'template': tmplt,
                'pool_by': f'sid={sid}',
                'avg rouge': np.mean(fdata['avg rouge']),
                'rouge var': np.var(fdata['avg rouge']),
                'N': len(fdata),
            })
    print(tabulate(out_vars, headers='keys', tablefmt='github'))



    
    # data = dict(zip(
    #     ['resp_id', 'problem', 'answer', 'response', 'metric', 'score'], 
    #     zip(*data_cur.fetchall())
    # ))

    # ds = Dataset.from_dict(data)

    
    ipshell = InteractiveShellEmbed()
    ipshell()

def cursor_generator(cursor, keys):
    for row in cursor:
        yield dict(zip(keys, row))
        
def make_ds(cursor, keys):
    return Dataset.from_dict(dict(zip(keys, zip(*cursor.fetchall()))))

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-p', '--path', type=str, required=True)
    args = parser.parse_args()
    main(args)