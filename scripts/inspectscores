#!/usr/bin/env python

import argparse
import sqlite3
import numpy as np
from datasets import Dataset
from pprint import pprint

from IPython.terminal.embed import InteractiveShellEmbed

def main(args):
    pth = args.path
    con = sqlite3.connect(pth)
    cur = con.cursor()
    tables = list(list(zip(*cur.execute(
        'select name from sqlite_master where type="table";'
    ).fetchall()))[0])

    columns = dict()
    for name in tables:
        tbl_info = cur.execute(f"PRAGMA table_info({name});").fetchall()
        _, cols, _, _, _, _ = zip(*tbl_info)
        columns[name] = list(cols)

    keys = columns['scores']

    metrics, = zip(*cur.execute(
        'select * from metric_names'
    ).fetchall())
    joinstr = '\n'
    query = (
        f"""
        SELECT R.rowid, R.model, P.template_name, P.problem_id, P.template_id, P.sys_id, F.problem, F.answer, R.response, {', '.join([f'{met}.score' for met in metrics])}
        FROM responses R
        JOIN prompts P on R.prompt_id=P.rowid
        JOIN fitb_problems F on P.problem_id=F.rowid
        JOIN source_data C on F.ref_id=C.rowid
        {joinstr.join([f'JOIN {met} on {met}.resp_id=R.rowid' for met in metrics])}
        """
    )
    data = cur.execute(query)

    keys = [
        'resp_id', 'model', 'template_name', 'problem_id', 
        'template_id', 'sys_id', 'problem', 'answer', 'response', 
    ] + list(metrics)
    
    # data = dict(zip(
    #     ['resp_id', 'problem', 'answer', 'response', 'metric', 'score'], 
    #     zip(*data_cur.fetchall())
    # ))

    # ds = Dataset.from_dict(data)

    
    ipshell = InteractiveShellEmbed()
    ipshell()

def cursor_generator(cursor, keys):
    for row in cursor:
        yield dict(zip(keys, row))
        
def make_ds(cursor, keys):
    return Dataset.from_dict(dict(zip(keys, zip(*cursor.fetchall()))))

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-p', '--path', type=str, required=True)
    args = parser.parse_args()
    main(args)